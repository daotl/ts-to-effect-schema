// Generated by ts-to-effect-schema
import * as S from '@effect/schema/Schema'
import type { IsEmptyObject } from 'type-fest'
import * as AST from '@effect/schema/AST'
import { pipe } from '@effect/data/Function'

// https://github.com/Effect-TS/schema/releases/tag/v0.18.0
// rome-ignore lint/suspicious/noExplicitAny: <explanation>
export const getPropertySchemas = <I extends { [K in keyof A]: any }, A>(
  schema: S.Schema<I, A>,
): { [K in keyof A]: S.Schema<I[K], A[K]> } => {
  const out: Record<PropertyKey, S.Schema<unknown>> = {}
  const propertySignatures = AST.getPropertySignatures(schema.ast)
  for (let i = 0; i < propertySignatures.length; i++) {
    const propertySignature = propertySignatures[i] as AST.PropertySignature
    out[propertySignature.name] = S.make(propertySignature.type)
  }
  // rome-ignore lint/suspicious/noExplicitAny: <explanation>
  return out as any
}

export type CommonKey<T, U, TK = keyof T, UK = keyof U> = {
  // @ts-expect-error
  [P in TK extends UK ? TK : never]: T[P]
}

const omitCommonProperties = <
  I extends { [K in keyof A]: unknown },
  A,
  IB extends { [K in keyof B]: unknown },
  B,
  R = IsEmptyObject<CommonKey<A, B>> extends true
    ? S.Schema<I, A>
    : S.Schema<I, Omit<A, keyof CommonKey<A, B>>>,
>(
  self: S.Schema<I, A>,
  that: S.Schema<IB, B>,
): R => {
  const selfObj = getPropertySchemas(self)
  const thatObj = getPropertySchemas(that)

  const intersections = Object.keys(selfObj).reduce<(keyof A)[]>(
    (keys, key) => {
      if (Reflect.has(thatObj, key)) {
        keys.push(key as keyof A)
      }

      return keys
    },
    [],
  ) as unknown as (keyof CommonKey<A, B>)[]

  if (intersections.length) {
    return pipe(
      self,
      S.omit<A, (keyof CommonKey<A, B>)[]>(...intersections),
    ) as unknown as R
  }

  return self as unknown as R
}

export const simplifiedJSDocTagSchema = S.struct({
  name: S.string,
  value: S.optional(S.string),
})

export const getSchemaNameSchema = S.any

export const nameFilterSchema = S.any

export const jSDocTagFilterSchema = S.any

export const configSchema = S.struct({
  input: S.string,
  output: S.string,
  skipValidation: S.optional(S.boolean),
  nameFilter: S.optional(nameFilterSchema),
  jsDocTagFilter: S.optional(jSDocTagFilterSchema),
  getSchemaName: S.optional(getSchemaNameSchema),
  keepComments: S.optional(S.boolean).withDefault(() => false),
  skipParseJSDoc: S.optional(S.boolean).withDefault(() => false),
  inferredTypes: S.optional(S.string),
})

export const configsSchema = S.array(
  pipe(
    configSchema,
    S.extend(
      omitCommonProperties(
        S.to(
          S.struct({
            name: S.string,
          }),
        ),
        S.to(configSchema),
      ),
    ),
  ),
)

export const tsToEffectConfigSchema = S.union(configSchema, configsSchema)
