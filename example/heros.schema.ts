// Generated by ts-to-effect-schema
import * as S from "@effect/schema/Schema";
import type {
  Primitive,
  ReadonlyDeep,
  IsAny,
  IsUnknown,
  IsEqual,
  IsEmptyObject,
} from "type-fest";
import * as AST from "@effect/schema/AST";
import type { Villain, EvilPlan, EvilPlanDetails } from "./heros";
import { EnemyPower } from "./heros";

// https://github.com/sindresorhus/type-fest/blob/2f64161921fc5e2d8e29d36ddaf2dc082017de35/source/internal.d.ts#L35
export type BuiltIns = Primitive | Date | RegExp;

export type ReplaceType<T, From, To> = IsEqual<T, From> extends true ? To : T;

export type ReplaceTypeDeep<T, From, To> = T extends BuiltIns
  ? ReplaceType<T, From, To>
  : IsAny<T> extends true
  ? ReplaceType<T, From, To>
  : IsUnknown<T> extends true
  ? ReplaceType<T, From, To>
  : // biome-ignore lint/complexity/noBannedTypes: <explanation>
  T extends Function
  ? ReplaceType<T, From, To>
  : {
      [K in keyof T]: ReplaceTypeDeep<T[K], From, To>;
    };

export type ReplaceDateToStringDeep<T> = ReplaceTypeDeep<T, Date, string>;

export type ObjectSchema<T extends object> = S.Schema<
  never,
  ReplaceDateToStringDeep<ReadonlyDeep<T>>,
  ReadonlyDeep<T>
>;

// https://github.com/Effect-TS/schema/releases/tag/v0.18.0
// biome-ignore lint/suspicious/noExplicitAny: <explanation>
export const getPropertySchemas = <I extends { [K in keyof A]: any }, A>(
  schema: S.Schema<never, I, A>
): { [K in keyof A]: S.Schema<never, I[K], A[K]> } => {
  const out: Record<PropertyKey, S.Schema<never, unknown>> = {};
  const propertySignatures = AST.getPropertySignatures(S.to(schema).ast);
  for (let i = 0; i < propertySignatures.length; i++) {
    const propertySignature = propertySignatures[i] as AST.PropertySignature;
    out[propertySignature.name] = S.make(propertySignature.type);
  }
  // biome-ignore lint/suspicious/noExplicitAny: <explanation>
  return out as any;
};

export type CommonKey<T, U, TK = keyof T, UK = keyof U> = {
  // @ts-expect-error
  [P in TK extends UK ? TK : never]: T[P];
};

const omitCommonProperties = <
  I extends { [K in keyof A]?: unknown },
  A,
  IB extends { [K in keyof B]?: unknown },
  B,
  R = IsEmptyObject<CommonKey<A, B>> extends true
    ? S.Schema<never, I, A>
    : S.Schema<
        never,
        Omit<I, keyof CommonKey<I, IB>>,
        Omit<A, keyof CommonKey<A, B>>
      >
>(
  self: S.Schema<never, I, A>,
  that: S.Schema<never, IB, B>
): R => {
  const selfObj = getPropertySchemas(self);
  const thatObj = getPropertySchemas(that);

  const intersections = Object.keys(selfObj).reduce<(keyof A)[]>(
    (keys, key) => {
      if (Reflect.has(thatObj, key)) {
        keys.push(key as keyof A);
      }

      return keys;
    },
    []
  ) as unknown as (keyof CommonKey<A, B>)[];

  if (intersections.length) {
    return self.pipe(
      S.omit<A, (keyof CommonKey<A, B>)[]>(...intersections)
    ) as unknown as R;
  }

  return self as unknown as R;
};

export const enemyPowerSchema = S.enums(EnemyPower);

export const skillsSpeedEnemySchema = S.struct({
  power: S.literal(EnemyPower.Speed),
});

export const enemySchema = S.struct({
  name: S.string,
  powers: S.array(enemyPowerSchema),
  inPrison: S.boolean,
});

export const supermanSchema = S.struct({
  name: S.union(
    S.literal("superman"),
    S.literal("clark kent"),
    S.literal("kal-l")
  ),
  enemies: S.record(S.string, enemySchema),
  age: S.number,
  underKryptonite: S.optional(S.boolean),
  powers: S.tuple(
    S.literal("fly"),
    S.literal("laser"),
    S.literal("invincible")
  ),
});

export const villainSchema: ObjectSchema<Villain> = S.suspend(() =>
  S.struct({
    name: S.string,
    powers: S.array(enemyPowerSchema),
    friends: S.array(villainSchema),
    canBeTrusted: S.never,
    age: S.unknown,
  })
);

export const storySchema = S.tuple(S.string, S.array(S.string));

export const killSupermanSchema = S.any;

export const withDefaultsSchema = S.struct({
  theAnswerToTheUltimateQuestionOfLife: S.optional(S.number, {
    default: () => 42 as const,
  }),
  isVulnerable: S.optional(S.boolean, {
    default: () => false as const,
  }),
  name: S.optional(
    S.union(S.literal("clark"), S.literal("superman"), S.literal("kal-l")),
    {
      default: () => "clark" as const,
    }
  ),
  theMeaningOf42: S.optional(S.string, {
    default: () => "The Answer to the Ultimate Question of Life" as const,
  }),
  emptyString: S.optional(S.string, {
    default: () => "" as const,
  }),
  booleanAsString: S.optional(S.string, {
    default: () => "true" as const,
  }),
});

const nonExportedSchema = S.struct({
  name: S.string,
});

export const exportedSchema = S.struct({
  a: nonExportedSchema,
  b: S.string,
});

export const getSupermanSkillSchema = S.any;

export const heroContactSchema = S.struct({
  email: S.string.pipe(
    S.pattern(
      /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9-]+(?:\.[a-zA-Z0-9-]+)*$/
    )
  ),
  name: S.string.pipe(S.minLength(2)).pipe(S.maxLength(50)),
  phoneNumber: S.string.pipe(
    S.pattern(/^([+]?d{1,2}[-s]?|)d{3}[-s]?d{3}[-s]?d{4}$/)
  ),
  hasSuperPower: S.optional(S.boolean, {
    default: () => true as const,
  }),
  age: S.number.pipe(S.greaterThanOrEqualTo(0)).pipe(S.lessThanOrEqualTo(500)),
});

const infoSchema = S.struct({
  age: S.number,
});

const uint8ArraySchema = S.instanceOf(Uint8Array);

const promiseSchema = S.instanceOf(Promise);

export const supermanEnemySchema = getPropertySchemas(supermanSchema).enemies;

export const supermanNameSchema = getPropertySchemas(supermanSchema).name;

export const supermanInvinciblePowerSchema = getPropertySchemas(
  getPropertySchemas(supermanSchema).powers
)[2];

export const krytonResponseSchema = promiseSchema;

const personSchema = S.struct({
  name: S.optional(S.string, {
    default: () => "dddd" as const,
  }),
  organizationLicensePhoto: S.optional(S.nullable(uint8ArraySchema)),
});

export const jimSchema = personSchema.pipe(
  S.extend(omitCommonProperties(infoSchema, personSchema))
);

export const evilPlanSchema: ObjectSchema<EvilPlan> = S.suspend(() =>
  S.struct({
    date: S.Date,
    owner: villainSchema,
    description: S.string,
    details: evilPlanDetailsSchema,
  })
);

export const evilPlanDetailsSchema: ObjectSchema<EvilPlanDetails> = S.suspend(
  () =>
    S.struct({
      parent: evilPlanSchema,
      u: uint8ArraySchema,
    })
);
