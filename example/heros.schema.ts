// Generated by ts-to-effect-schema
import * as S from "@effect/schema/Schema";
import type {
  Primitive,
  ReadonlyDeep,
  IsAny,
  IsUnknown,
  IsEqual,
  IsEmptyObject,
} from "type-fest";
import * as AST from "@effect/schema/AST";
import { pipe } from "@effect/data/Function";
import type { Villain, EvilPlan, EvilPlanDetails } from "./heros";
import { EnemyPower } from "./heros";

// https://github.com/sindresorhus/type-fest/blob/2f64161921fc5e2d8e29d36ddaf2dc082017de35/source/internal.d.ts#L35
export type BuiltIns = Primitive | Date | RegExp;

export type ReplaceType<T, From, To> = IsEqual<T, From> extends true ? To : T;

export type ReplaceTypeDeep<T, From, To> = T extends BuiltIns
  ? ReplaceType<T, From, To>
  : IsAny<T> extends true
  ? ReplaceType<T, From, To>
  : IsUnknown<T> extends true
  ? ReplaceType<T, From, To>
  : T extends Function
  ? ReplaceType<T, From, To>
  : {
      [K in keyof T]: ReplaceTypeDeep<T[K], From, To>;
    };

export type ReplaceDateToStringDeep<T> = ReplaceTypeDeep<T, Date, string>;

export type ObjectSchema<T extends Object> = S.Schema<
  ReplaceDateToStringDeep<ReadonlyDeep<T>>,
  ReadonlyDeep<T>
>;

// https://github.com/Effect-TS/schema/releases/tag/v0.18.0
// rome-ignore lint/suspicious/noExplicitAny: <explanation>
export const getPropertySchemas = <I extends { [K in keyof A]: any }, A>(
  schema: S.Schema<I, A>
): { [K in keyof A]: S.Schema<I[K], A[K]> } => {
  const out: Record<PropertyKey, S.Schema<unknown>> = {};
  const propertySignatures = AST.getPropertySignatures(schema.ast);
  for (let i = 0; i < propertySignatures.length; i++) {
    const propertySignature = propertySignatures[i] as AST.PropertySignature;
    out[propertySignature.name] = S.make(propertySignature.type);
  }
  // rome-ignore lint/suspicious/noExplicitAny: <explanation>
  return out as any;
};

export type CommonKey<T, U, TK = keyof T, UK = keyof U> = {
  // @ts-expect-error
  [P in TK extends UK ? TK : never]: T[P];
};

const omitCommonProperties = <
  I extends { [K in keyof A]: unknown },
  A,
  IB extends { [K in keyof B]: unknown },
  B,
  R = IsEmptyObject<CommonKey<A, B>> extends true
    ? S.Schema<I, A>
    : S.Schema<I, Omit<A, keyof CommonKey<A, B>>>
>(
  self: S.Schema<I, A>,
  that: S.Schema<IB, B>
): R => {
  const selfObj = getPropertySchemas(self);
  const thatObj = getPropertySchemas(that);

  const intersections = Object.keys(selfObj).reduce<(keyof A)[]>(
    (keys, key) => {
      if (Reflect.has(thatObj, key)) {
        keys.push(key as keyof A);
      }

      return keys;
    },
    []
  ) as unknown as (keyof CommonKey<A, B>)[];

  if (intersections.length) {
    return pipe(
      self,
      S.omit<A, (keyof CommonKey<A, B>)[]>(...intersections)
    ) as unknown as R;
  }

  return self as unknown as R;
};

export const enemyPowerSchema = S.enums(EnemyPower);

export const skillsSpeedEnemySchema = S.struct({
  power: S.literal(EnemyPower.Speed),
});

export const enemySchema = S.struct({
  name: S.string,
  powers: S.array(enemyPowerSchema),
  inPrison: S.boolean,
});

export const supermanSchema = S.struct({
  name: S.union(
    S.literal("superman"),
    S.literal("clark kent"),
    S.literal("kal-l")
  ),
  enemies: S.record(S.string, enemySchema),
  age: S.number,
  underKryptonite: S.optional(S.boolean),
  powers: S.tuple(
    S.literal("fly"),
    S.literal("laser"),
    S.literal("invincible")
  ),
});

export const villainSchema: ObjectSchema<Villain> = S.lazy(() =>
  S.struct({
    name: S.string,
    powers: S.array(enemyPowerSchema),
    friends: S.array(villainSchema),
    canBeTrusted: S.never,
    age: S.unknown,
  })
);

export const storySchema = S.tuple(S.string, S.array(S.string));

export const killSupermanSchema = S.any;

export const withDefaultsSchema = S.struct({
  theAnswerToTheUltimateQuestionOfLife: S.optional(S.number).withDefault(
    () => 42
  ),
  isVulnerable: S.optional(S.boolean).withDefault(() => false),
  name: S.optional(
    S.union(S.literal("clark"), S.literal("superman"), S.literal("kal-l"))
  ).withDefault(() => "clark"),
  theMeaningOf42: S.optional(S.string).withDefault(
    () => "The Answer to the Ultimate Question of Life"
  ),
  emptyString: S.optional(S.string).withDefault(() => ""),
  booleanAsString: S.optional(S.string).withDefault(() => "true"),
});

const nonExportedSchema = S.struct({
  name: S.string,
});

export const exportedSchema = S.struct({
  a: nonExportedSchema,
  b: S.string,
});

export const getSupermanSkillSchema = S.any;

export const heroContactSchema = S.struct({
  email: pipe(
    S.string,
    S.pattern(
      /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9-]+(?:\.[a-zA-Z0-9-]+)*$/
    )
  ),
  name: pipe(S.string, S.minLength(2), S.maxLength(50)),
  phoneNumber: pipe(
    S.string,
    S.pattern(/^([+]?d{1,2}[-s]?|)d{3}[-s]?d{3}[-s]?d{4}$/)
  ),
  hasSuperPower: S.optional(S.boolean).withDefault(() => true),
  age: pipe(S.number, S.greaterThanOrEqualTo(0), S.lessThanOrEqualTo(500)),
});

const infoSchema = S.struct({
  age: S.number,
});

const uint8ArraySchema = S.instanceOf(Uint8Array);

const promiseSchema = S.instanceOf(Promise);

export const supermanEnemySchema = getPropertySchemas(
  S.to(supermanSchema)
).enemies;

export const supermanNameSchema = getPropertySchemas(S.to(supermanSchema)).name;

export const supermanInvinciblePowerSchema = getPropertySchemas(
  S.to(getPropertySchemas(S.to(supermanSchema)).powers)
)[2];

export const krytonResponseSchema = promiseSchema;

const personSchema = S.struct({
  name: S.optional(S.string).withDefault(() => "dddd"),
  organizationLicensePhoto: S.optional(S.nullable(uint8ArraySchema)),
});

export const jimSchema = pipe(
  personSchema,
  S.extend(omitCommonProperties(S.to(infoSchema), S.to(personSchema)))
);

export const evilPlanSchema: ObjectSchema<EvilPlan> = S.lazy(() =>
  S.struct({
    date: S.Date,
    owner: villainSchema,
    description: S.string,
    details: evilPlanDetailsSchema,
  })
);

export const evilPlanDetailsSchema: ObjectSchema<EvilPlanDetails> = S.lazy(() =>
  S.struct({
    parent: evilPlanSchema,
    u: uint8ArraySchema,
  })
);
